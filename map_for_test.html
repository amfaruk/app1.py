<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Utility Infrastructure Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
   <!-- Add this to your head section -->
<script src="https://cdn.jsdelivr.net/npm/geojson@0.5.0/geojson.min.js"></script>

<!-- Buffer controls will be automatically added by JavaScript -->
   <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        #map {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 1;
        }
        
        .loading-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        
        .message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .message-box.show {
            opacity: 1;
        }
        
        .zoom-level-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
        }
        
        .layer-control-panel {
            position: fixed;
            bottom: 60px;
            right: 15px;
            width: 320px;
            max-height: 80vh;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            transform: translateX(120%);
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
            z-index: 1001;
        }
        .layer-control-panel.show {
            transform: translateX(0);
        }
        .layer-icon-button {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 48px;
            height: 48px;
            background-color: #2563eb;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease-in-out;
            z-index: 1000;
        }

        .layer-icon-button:hover {
            transform: scale(1.05);
        }

        
        #search-container {
            position: absolute;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            top: 75px;
            left: 10px;
            width: 300px;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        #search-container.collapsed {
            width: 40px;
            height: 40px;
            padding: 0;
            overflow: hidden;
        }
        
        #search-container.collapsed #search-wrapper,
        #search-container.collapsed #search-results,
        #search-container.collapsed #search-info,
        #search-container.collapsed h3 {
            display: none;
        }
        
        .search-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #6b7280;
            z-index: 1001;
        }
        
        .text-lg {
            font-size: 1.125rem;
        }
        
        .font-bold {
            font-weight: 700;
        }
        
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        
        .mr-2 {
            margin-right: 0.5rem;
        }
        
        #search-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        #search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        #search-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        #search-clear-button {
            position: absolute;
            right: 10px;
            cursor: pointer;
            color: #6b7280;
            display: none;
            background: #f3f4f6;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            text-align: center;
            line-height: 22px;
            font-size: 12px;
        }
        
        #search-results {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }
        
        .search-result-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .search-result-item:hover {
            background-color: #f3f4f6;
        }
        
        .search-info {
            margin-top: 8px;
            font-size: 12px;
            color: #6b7280;
        }
        
        .text-gray-500 {
            color: #6b7280;
        }
        
        .layer-category {
            margin-bottom: 10px;
        }
        
        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            cursor: pointer;
            font-weight: 600;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 8px 12px;
        }
        
        .category-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            padding-left: 0.5rem;
        }

        .category-content.expanded {
            max-height: 500px;
            padding-top: 0.5rem;
        }
        .layer-count, .zoom-note {
            font-size: 0.75rem;
            color: #6b7280;
            margin-left: auto;
            white-space: nowrap;
        }
        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 4px 0;
        }

        .legend-icon {
            width: 20px;
            height: 6px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 0.5rem;
        }
        
        .electric-tower-icon, .power-plant-icon, .substation-icon, .airport-icon, .telecom-icon, 
        .transformer-icon, .railway-icon, .railway-substation-icon, .asphalt-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            text-align: center;
            line-height: 12px;
        }
        
        .power-plant-icon {
            background-color: #10B981;
            border-radius: 50%;
        }
        
        .substation-icon {
            background-color: #EF4444;
            border-radius: 2px;
        }
        
        .telecom-icon {
            background-color: #3B82F6;
            border-radius: 50%;
        }
        
        .transformer-icon {
            background-color: #FFA500;
            border-radius: 50%;
        }
        
       .railway-icon {
           position: relative;
           width: 100px;
           height: 30px;
           background-color: #5e5b59;
           border-radius: 3px;
           overflow: hidden;
        }

        .railway-icon::before,
        .railway-icon::after {
            content: '';
            position: absolute;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #c8c8c8;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }

        .railway-icon::before {
            top: 7px;
        }

        .railway-icon::after {
            bottom: 7px;
        }

        .railway-icon .broken-line {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
            background: repeating-linear-gradient(
              to right,
             #ffd700,
             #ffd700 10px,
             transparent 10px,
             transparent 20px
            );
        }
        
        .railway-substation-icon {
            background-color: #ef7408;
            border-radius: 2px;
        }
        
        .asphalt-icon {
            background-color: #2c3e50;
            height: 4px;
            width: 100%;
            position: relative;

        }
        
        .layer-count {
            margin-left: auto;
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }
        
        .zoom-note {
            margin-left: auto;
            font-size: 10px;
            color: #6b7280;
            font-style: italic;
        }
        
        .custom-layer-control {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .layer-box-toggle {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            color: #2563eb;
        }
        
        .layer-box-content {
            position: absolute;
            top: 50px;
            right: 0;
            width: 200px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            display: none;
        }
        
        .layer-box-title {
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e5e7eb;
            color: #2563eb;
        }
        
        .base-layer-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
        }
        
        .base-layer-item label {
            cursor: pointer;
        }
        
        .electric-tower-marker {
            font-size: 18px;
            text-align: center;
            line-height: 24px;
        }
        
        .power-plant-marker, .substation-marker, .transformer-marker, 
        .railway-substation-marker {
            text-align: center;
        }
        
        .airport-marker {
            font-size: 18px;
            text-align: center;
            line-height: 24px;
        }
        
        .popup-header {
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .feature-properties {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .property-row {
            display: flex;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .property-name {
            font-weight: 600;
            margin-right: 5px;
            flex-shrink: 0;
        }
        
        .property-value {
            word-break: break-word;
        }
        
        /* Ethiopia region styling */
        .ethiopia-region {
            fill-opacity: 0.1;
            stroke: #888888;
            stroke-width: 2;
        }
        
        .ethiopia-zone {
            fill-opacity: 0.05;
            stroke: #AAAAAA;
            stroke-width: 1.5;
        }
        
        .ethiopia-woreda {
            fill-opacity: 0.02;
            stroke: #CCCCCC;
            stroke-width: 1;
        }
        
        .loading-priority {
            color: #3B82F6;
            font-weight: bold;
        }
        
        .safaricom-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            background-color: #0072ce;
            border-radius: 50%;
        }
        
        /* Improved styling for better visual distinction */
        .data-layer-icon {
            color: #10B981;
        }
        
        .base-layer-icon {
            color: #2563eb;
        }
        
        .category-header:hover {
            background-color: #e9ecef;
        }
        
        /* Custom zoom controls */
        .leaflet-bottom.leaflet-right {
            top: auto;
            bottom: 120px;
            right: 15px;
        }
        
        .leaflet-control-zoom {
            margin-bottom: 80px !important;
            margin-right: 0 !important;
            border: none !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            border-radius: 8px !important;
            overflow: hidden;
        }
        
        .leaflet-control-zoom a {
            width: 32px !important;
            height: 32px !important;
            line-height: 32px !important;
            font-size: 18px !important;
            background: white !important;
            color: #2563eb !important;
            border: none !important;
            border-radius: 0 !important;
        }
        
        .leaflet-control-zoom a:first-child {
            border-bottom: 1px solid #e5e7eb !important;
        }
        
        .leaflet-control-zoom a:hover {
            background: #f8f9fa !important;
        }
        
        /* Search toggle button */
        .search-toggle-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #6b7280;
            z-index: 1001;
        }
        /* Buffer Control Panel Styles */
    .buffer-control-panel {
        position: fixed;
        bottom: 60px;
        left: 15px;
        width: 320px;
        max-height: 80vh;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        padding: 1.5rem;
        transform: translateX(-120%);
        transition: transform 0.3s ease-in-out;
        overflow-y: auto;
        z-index: 1001;
    }
    
    .buffer-control-panel.show {
        transform: translateX(0);
    }
    
    .buffer-icon-button {
        position: fixed;
        bottom: 15px;
        left: 15px;
        width: 48px;
        height: 48px;
        background-color: #10B981;
        color: white;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.25rem;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        transition: transform 0.2s ease-in-out;
        z-index: 1000;
    }

    .buffer-icon-button:hover {
        transform: scale(1.05);
    }
    
    .buffer-section {
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .buffer-section:last-child {
        border-bottom: none;
    }
    
    .buffer-section-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #2563eb;
    }
    
    .buffer-option {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .buffer-input-group {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .buffer-input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 14px;
    }
    
    .buffer-unit {
        margin-left: 8px;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        background-color: #f9fafb;
        font-size: 14px;
    }
    
    .buffer-button {
        width: 100%;
        padding: 10px;
        background-color: #10B981;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        margin-top: 10px;
    }
    
    .buffer-button:hover {
        background-color: #059669;
    }
    
    .buffer-button:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
    }
    
    .buffer-results {
        margin-top: 1rem;
        padding: 10px;
        background-color: #f9fafb;
        border-radius: 6px;
        display: none;
    }
    
    .buffer-results.show {
        display: block;
    }
    
    .buffer-result-item {
        padding: 8px;
        margin-bottom: 5px;
        background-color: white;
        border-radius: 4px;
        border-left: 3px solid #10B981;
    }
    
    .buffer-clear-button {
        width: 100%;
        padding: 8px;
        background-color: #ef4444;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        margin-top: 10px;
    }
    
    .buffer-clear-button:hover {
        background-color: #dc2626;
    }
    
    /* Buffer layer styling */
    .point-buffer {
        fillColor: '#3B82F6';
        color: '#1D4ED8';
        weight: 2;
        fillOpacity: 0.2;
    }
    
    .road-buffer {
        fillColor: '#EF4444';
        color: '#DC2626';
        weight: 2;
        fillOpacity: 0.2;
    }
    
    .forest-buffer {
        fillColor: '#10B981';
        color: '#059669';
        weight: 2;
        fillOpacity: 0.2;
    }
    
    .intersection-point {
        color: '#8B5CF6';
        weight: 3;
        fillColor: '#8B5CF6';
        fillOpacity: 0.8;
        radius: 6;
    }
    /* Buffer Controls */
.map-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 1000;
    max-width: 300px;
}

.control-header {
    display: flex;
    justify-content: between;
    align-items: center;
    margin-bottom: 15px;
}

.control-header h4 {
    margin: 0;
    flex: 1;
}

.close-btn {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
}

.control-section {
    margin-bottom: 15px;
}

.control-section label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.distance-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

#buffer-distance-slider {
    flex: 1;
}

#buffer-distance-input {
    width: 80px;
}

.layer-checkboxes {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    max-height: 150px;
    overflow-y: auto;
}

.btn-primary, .btn-secondary, .btn-small {
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 5px;
}

.btn-primary {
    background: #007bff;
    color: white;
}

.btn-secondary {
    background: #6c757d;
    color: white;
}

.btn-small {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 4px 8px;
    font-size: 12px;
}

.selection-info {
    background: #f8f9fa;
    padding: 10px;
    border-radius: 4px;
    font-size: 14px;
}

/* Results Panel */
.results-panel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 1000;
    max-width: 400px;
    max-height: 300px;
    overflow-y: auto;
}

.intersection-item {
    border-bottom: 1px solid #eee;
    padding: 8px 0;
}

.intersection-item:last-child {
    border-bottom: none;
}

.intersection-properties {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
}

/* Map Tool Button */
.map-tool-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    background: white;
    border: none;
    padding: 10px 15px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 1000;
}
/* Buffer instructions marker */
.buffer-instructions-marker {
    background: rgba(255, 255, 255, 0.95);
    border: 2px solid #10B981;
    border-radius: 8px;
    padding: 5px;
    text-align: center;
    font-size: 12px;
    font-weight: bold;
    color: #10B981;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.buffer-instructions-marker:hover {
    background: rgba(255, 255, 255, 1);
    transform: scale(1.05);
    transition: all 0.2s ease;
}

/* Selection help layer - make sure it's non-interactive */
.selection-help-layer {
    pointer-events: none !important;
}
.click-feedback {
    animation: pulse 0.5s ease-in-out;
    pointer-events: none;
    z-index: 10000;
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.7; }
    100% { transform: scale(1); opacity: 1; }
}

.buffer-selection-layer {
    pointer-events: all;
    cursor: crosshair;
}

.map-tool-btn.active {
    background: #007bff;
    color: white;
}
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="loading" class="loading-indicator">
        <i class="fas fa-spinner fa-spin"></i> <span class="loading-priority">Loading priority layers...</span>
    </div>
    <div id="message-box" class="message-box"></div>
    <div id="zoom-level" class="zoom-level-info">Zoom Level: 6</div>
    
    <div id="search-container" class="map-control">
        <button class="search-toggle-btn" id="search-toggle">
            <i class="fas fa-search"></i>
        </button>
        <h3 class="text-lg font-bold mb-2">🔎 Search</h3>
        <div id="search-wrapper">
            <input type="text" id="search-input" placeholder="Type to search...">
            <i id="search-clear-button" class="fa-solid fa-xmark"></i>
        </div>
        <div id="search-results"></div>
        <div id="search-info" class="search-info"></div>
    </div>
    
    <div id="layer-control" class="layer-control-panel">
        <h3 class="text-lg font-bold mb-2"><i class="fas fa-layer-group data-layer-icon"></i> Data Layers</h3>
        
        <div class="layer-category">
            <div class="category-header" data-category="power">
                <span><i class="fas fa-bolt mr-2"></i>Electric Power</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="category-content" id="power-content">
                <div class="layer-item">
                    <input type="checkbox" id="132kv" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #2f86ff;width: 20px; height: 6px;"></span>
                    <label for="132kv">132KV Lines</label>
                    <span class="layer-count" data-layer="132kv">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="230kv" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #1242bc;width: 20px; height: 6px;"></span>
                    <label for="230kv">230KV Lines</label>
                    <span class="layer-count" data-layer="230kv">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="400kv" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #0f056e;width: 20px; height: 6px;"></span>
                    <label for="400kv">400KV Lines</label>
                    <span class="layer-count" data-layer="400kv">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="500kv" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #6004f5;width: 20px; height: 6px;"></span>
                    <label for="500kv">500KV Lines</label>
                    <span class="layer-count" data-layer="500kv">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Power_Plants" class="mr-2" checked>
                    <span class="power-plant-icon">  </span>
                    <label for="Power_Plants"> Power Plants</label>
                    <span class="layer-count" data-layer="Power_Plants">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Electric_Tower" class="mr-2" checked>
                    <span class="electric-tower-icon" style="background-image: url('/static/Electric tower.png');"></span>
                    <label for="Electric_Tower">Electric Towers</label>
                    <span class="zoom-note">zoom_level(16)</span>
                    <span class="layer-count" data-layer="Electric_Tower">0</span>
                </div>
            </div>
        </div>
        
        <div class="layer-category">
            <div class="category-header" data-category="electric">
                <span><i class="fas fa-plug mr-2"></i>Electric Utility</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="category-content" id="electric-content">
                <div class="layer-item">
                    <input type="checkbox" id="mv" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #f00606;width: 20px; height: 6px;"></span>
                    <label for="mv">MV Lines</label>
                    <span class="zoom-note">zoom_level(16)</span>
                    <span class="layer-count" data-layer="mv">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Transformer" class="mr-2" checked>
                    <span class="transformer-icon" style="background-image: url('/static/transformer.png');"> </span>
                    <label for="Transformer"> Transformers</label>
                    <span class="zoom-note">zoom_level(16)</span>
                    <span class="layer-count" data-layer="Transformer">0</span>
                </div>
            </div>
        </div>
        
        <div class="layer-category">
            <div class="category-header" data-category="transport">
                <span><i class="fas fa-road mr-2"></i>Transport</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="category-content" id="transport-content">
                <div class="layer-item">
                    <input type="checkbox" id="airports" class="mr-2" checked>
                    <span class="airport-icon" style="background-image: url('/static/Airports.png');"></span>
                    <label for="airports">Airports</label>
                    <span class="layer-count" data-layer="airports">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="roads" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #3c363c;width: 20px; height: 6px;"></span>
                    <label for="roads">Express Roads</label>
                    <span class="layer-count" data-layer="roads">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Asphalt" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #121212;width: 20px; height: 6px;"></span>
                    <label for="Asphalt">Asphalt Roads</label>
                    <span class="zoom-note">zoom_level(14)</span>
                    <span class="layer-count" data-layer="Asphalt">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Railway" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #5e5b59;width: 20px; height: 6px;"></span>
                    <label for="Railway">Railway Lines</label>
                    <span class="layer-count" data-layer="Railway">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Sub_Station" class="mr-2" checked>
                    <span class="substation-icon" style="background-image: url('/static/Electric substation.png');"> </span>
                    <label for="Sub_Station"> Railway Sub Stations</label>
                    <span class="zoom-note">zoom_level(10)</span>
                    <span class="layer-count" data-layer="Sub_Station">0</span>
                </div>
            </div>
        </div>
        
        <div class="layer-category">
            <div class="category-header" data-category="other">
                <span><i class="fas fa-tower-cell mr-2"></i>Tele communication</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="category-content" id="other-content">
                <div class="layer-item">
                    <input type="checkbox" id="telecom" class="mr-2" checked>
                    <span class="telecom-icon" style="background-image: url('/static/Tele tower.png');"></span>
                    <label for="telecom">Ethio telecom Towers</label>
                    <span class="zoom-note">zoom_level(16)</span>
                    <span class="layer-count" data-layer="telecom">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="Safaricom" class="mr-2" checked>
                    <span class="safaricom-icon"></span>
                    <label for="Safaricom">Safari telecom Towers</label>
                    <span class="zoom-note">zoom_level(10)</span>
                    <span class="layer-count" data-layer="Safaricom">0</span>
                </div>
            </div>
        </div>
        
        <div class="layer-category">
            <div class="category-header" data-category="ethiopia">
                <span><i class="fas fa-map mr-2"></i>Ethiopia Boundaries</span>
                <span class="collapse-icon">▼</span>
            </div>
           <div class="category-content" id="ethiopia-content">
                <div class="layer-item">
                    <input type="checkbox" id="ethiopia_regions" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #080202;"></span>
                    <label for="ethiopia_regions">Regions (ADM1)</label>
                    <span class="layer-count" data-layer="ethiopia_regions">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="ethiopia_zones" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #393737;"></span>
                    <label for="ethiopia_zones">Zones (ADM2)</label>
                    <span class="zoom-note">zoom_level(6)</span>
                    <span class="layer-count" data-layer="ethiopia_zones">0</span>
                </div>
                <div class="layer-item">
                    <input type="checkbox" id="ethiopia_woredas" class="mr-2" checked>
                    <span class="legend-icon" style="background-color: #702929;"></span>
                    <label for="ethiopia_woredas">Woredas (ADM3)</label>
                    <span class="zoom-note">zoom_level(8)</span>
                    <span class="layer-count" data-layer="ethiopia_woredas">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Layer control button -->
    <div class="layer-icon-button" id="layer-control-button">
        <i class="fas fa-layer-group"></i>
    </div>
    
    <!-- Custom layer control box -->
    <div class="custom-layer-control">
        <div class="layer-box-toggle" id="base-layer-toggle">
            <i class="fas fa-map base-layer-icon"></i>
        </div>
        <div class="layer-box-content" id="base-layer-content">
            <div class="layer-box-title"><i class="fas fa-globe base-layer-icon"></i> Base Maps</div>
            <div class="base-layer-item">
                <input type="radio" name="baseMap" id="openStreetMap" class="mr-2" checked>
                <label for="openStreetMap">OpenStreetMap</label>
            </div>
            <div class="base-layer-item">
                <input type="radio" name="baseMap" id="worldStreetMap" class="mr-2">
                <label for="worldStreetMap">World Street Map</label>
            </div>
            <div class="base-layer-item">
                <input type="radio" name="baseMap" id="satelliteMap" class="mr-2">
                <label for="satelliteMap">Satellite</label>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="">
    </script>
    
    <script>
        // Set the base URL for your Flask API
        const API_URL = 'http://localhost:5000/api';

        // Initialize map
        const map = L.map('map').setView([9.145, 40.4897], 6);
        const loadingIndicator = document.getElementById('loading');
        const searchInfo = document.getElementById('search-info');
        const zoomLevelInfo = document.getElementById('zoom-level');
        let currentSearchMarker = null;
        const mapLayers = {};
        
        // Define zoom thresholds for different layers
        const ZOOM_THRESHOLDS = {
            'Sub_Station': 10,
            'Transformer': 16,    
            'mv': 16,          
            'telecom': 16,        
            'Railway_Substation': 0, 
            'Railway': 0,
            '132kv': 8,
            '230kv': 8,
            '400kv': 8,
            '500kv': 8,
            'Power_Plants': 8, 
            'Asphalt': 14,       
            'ethiopia_regions': 0,  
            'ethiopia_zones': 8,    
            'ethiopia_woredas': 10,
            'Safaricom': 10
        };
        
        // Define the order in which layers should be displayed (from bottom to top)
        const LAYER_DISPLAY_ORDER = [
            'ethiopia_regions',
            'airports',
            'roads',
            'ethiopia_woredas',
            'ethiopia_zones',
            'Asphalt',
            'Railway',
            '132kv',
            '230kv',
            '400kv',
            '500kv',
            'Power_Plants',
            'Sub_Station',
            'Railway_Substation',
            'telecom',
            'Safaricom',
            'mv',          
            'Transformer'
            
        ];

        // Define priority layers that should load first
        const PRIORITY_LAYERS = [
            'ethiopia_regions',
            'airports',
            'Power_Plants',
            'roads',
            '132kv',
            '230kv',
            '400kv',
            '500kv'
        ];

        // Simple authFetch implementation (just a wrapper for fetch)
        function authFetch(url, options = {}) {
            return fetch(url, options);
        }

        // Show/hide loading indicator
        function showLoading(message = 'Loading map data...') {
            loadingIndicator.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${message}`;
            loadingIndicator.style.display = 'block';
        }
        
        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }
        
        function showMessageBox(message) {
            const msgBox = document.getElementById('message-box');
            msgBox.textContent = message;
            msgBox.classList.add('show');
            setTimeout(() => {
                msgBox.classList.remove('show');
            }, 5000);
        }

        function updateSearchInfo(message) {
            searchInfo.textContent = message;
        }
        
        function updateZoomLevelInfo() {
            const zoom = map.getZoom();
            zoomLevelInfo.textContent = `Zoom Level: ${zoom}`;
        }

        // Define base maps
        const baseMaps = {
            "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }),
            "World Street Map": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community',
                maxZoom: 19
            }),
            "Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 19
            })
        };
        
        // Add default base map
        baseMaps["OpenStreetMap"].addTo(map);
        
        // Set up base map switching
        document.querySelectorAll('input[name="baseMap"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const mapType = e.target.id;
                // Remove all current base layers
                for (const key in baseMaps) {
                    if (map.hasLayer(baseMaps[key])) {
                        map.removeLayer(baseMaps[key]);
                    }
                }
                
                // Add the selected base layer
                switch(mapType) {
                    case 'openStreetMap':
                        baseMaps["OpenStreetMap"].addTo(map);
                        break;
                    case 'worldStreetMap':
                        baseMaps["World Street Map"].addTo(map);
                        break;
                    case 'satelliteMap':
                        baseMaps["Satellite"].addTo(map);
                        break;
                }
            });
        });

        // Create overlay layers object
        const overlayMaps = {};
        
        // Function to get the PNG filename for specific layers
        function getIconFilename(layerId) {
            const filenames = {
                'Sub_Station': 'Electric substation.png',
                'Transformer': 'transformer.png',
                'airports': 'Airports.png',
                'telecom': 'Tele tower.png',
                'Safaricom': 'safaricom_icon.png'
            };
            return filenames[layerId];
        }

        // Function to create appropriate icons for each layer type
        function createLayerIcon(layerId, feature) {
            // Use PNG icons for specified layers
            if (['Sub_Station', 'Transformer', 'airports', 'telecom', 'Safaricom'].includes(layerId)) {
                const filename = getIconFilename(layerId);
                if (filename) {
                    return L.icon({
                        iconUrl: `/static/${filename}`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                }
            } else if (layerId === 'Power_Plants') {
                return L.divIcon({
                    className: 'power-plant-marker',
                    html: '<div class="power-plant-icon"></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
            } else if (layerId === 'Railway_Substation') {
                return L.divIcon({
                    className: 'railway-substation-marker',
                    html: '<div class="railway-substation-icon"></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
            }
            
            // Default icon for other point features
            return L.divIcon({
                className: 'default-marker',
                html: '<div style="background-color: #3388ff; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // Function to load a single layer
        async function loadLayer(layerId, layerInfo) {
            try {
                if (!layerInfo.geojson) {
                    console.warn(`No GeoJSON specified for layer ${layerId}`);
                    return;
                }

                const geojsonResponse = await authFetch(`${API_URL}/geojson/${layerInfo.geojson}`);
                if (!geojsonResponse.ok) {
                    console.error(`Failed to fetch GeoJSON for ${layerId}:`, geojsonResponse.statusText);
                    return;
                }
                
                const geojsonData = await geojsonResponse.json();
                console.log(`Loaded ${layerId} with ${geojsonData.features ? geojsonData.features.length : 0} features`);
                
                if (!geojsonData.features || geojsonData.features.length === 0) {
                    console.warn(`No features found in GeoJSON for ${layerId}`);
                    return;
                }
                
                // Create the Leaflet GeoJSON layer with appropriate styling for Ethiopia layers
                const layer = L.geoJSON(geojsonData, {
                    style: feature => {
                        // Special styling for Ethiopia administrative boundaries
                        if (layerId === 'ethiopia_zones') {
                            return {
                                color: '#AAAAAA',
                                weight: 1.5,
                                opacity: 0.7,
                                className: 'ethiopia-zone'
                            };
                        } else if (layerId === 'ethiopia_woredas') {
                            return {
                                color: '#CCCCCC',
                                weight: 1,
                                opacity: 0.6,
                                className: 'ethiopia-woreda'
                            };
                        } else {
                            // Default styling for other layers
                            return {
                                color: getLayerColor(layerId),
                                weight: getLayerWeight(layerId),
                                opacity: 0.8,
                                fillOpacity: layerId.startsWith('ethiopia') ? 0.1 : 0.8,
                                fillColor: layerId.startsWith('ethiopia') ? getLayerColor(layerId) : 'transparent'
                            };
                        }
                    },
                    pointToLayer: (feature, latlng) => {
                        // Use our custom icon function
                        const icon = createLayerIcon(layerId, feature);
                        return L.marker(latlng, { icon: icon, riseOnHover: true });
                    },
                    onEachFeature: (feature, layer) => {
                        layer.bindPopup(`<div class="popup-header">${layerInfo.name}</div>${formatProperties(feature.properties)}`);
                    }
                });
                
                mapLayers[layerId] = layer;
                
                // Add to overlayMaps for all layers including Ethiopia layers
                overlayMaps[layerInfo.name] = layer;

                // Update layer counts on the UI for all layers
                const countElement = document.querySelector(`.layer-count[data-layer="${layerId}"]`);
                if (countElement) {
                    countElement.textContent = geojsonData.features.length;
                }
                
                // Add to map immediately if it should be visible
                const isCheckboxChecked = document.getElementById(layerId)?.checked || false;
                const zoomThreshold = ZOOM_THRESHOLDS[layerId] || 0;
                const shouldBeVisible = isCheckboxChecked && map.getZoom() >= zoomThreshold;
                
                if (shouldBeVisible) {
                    map.addLayer(layer);
                }
                
                return true;
            } catch (error) {
                console.error(`Error loading GeoJSON for layer ${layerId}:`, error);
                showMessageBox(`Failed to load data for ${layerInfo.name}`);
                return false;
            }
        }

        // This function fetches the list of layers from the backend and loads the GeoJSON data for each
        async function loadLayersFromBackend() {
            showLoading('Loading priority layers...');
            try {
                // Fetch the layer metadata from the /api/layers endpoint
                const layersResponse = await authFetch(`${API_URL}/layers`);
                if (!layersResponse.ok) {
                    throw new Error(`HTTP error! status: ${layersResponse.status}`);
                }
                
                const layersData = await layersResponse.json();
                
                // Clear any existing layers
                Object.values(mapLayers).forEach(layer => map.removeLayer(layer));
                for (const key in mapLayers) { delete mapLayers[key]; }
                
                // Clear overlayMaps
                for (const key in overlayMaps) { delete overlayMaps[key]; }
                
                // Load priority layers first
                for (const layerId of PRIORITY_LAYERS) {
                    const layerInfo = layersData[layerId];
                    if (!layerInfo) continue;
                    
                    console.log("Loading priority layer:", layerId);
                    await loadLayer(layerId, layerInfo);
                }
                
                // Hide loading indicator after priority layers are loaded
                hideLoading();
                
                // Load remaining layers in the background
                const remainingLayers = LAYER_DISPLAY_ORDER.filter(layerId => 
                    !PRIORITY_LAYERS.includes(layerId) && layersData[layerId]
                );
                
                for (const layerId of remainingLayers) {
                    const layerInfo = layersData[layerId];
                    console.log("Loading background layer:", layerId);
                    loadLayer(layerId, layerInfo); // Don't await - load in background
                }
                
                updateLayersVisibilityByZoom();
                updateSearchInfo('Search data layer.');

            } catch (error) {
                console.error("Error fetching layers metadata:", error);
                hideLoading();
                showMessageBox("Failed to connect to the backend. Please ensure the Flask server is running.");
            }
        }
        
        function getLayerColor(layerId) {
            const colors = {
                '132kv': '#2f86ff', '230kv': '#1242bc', '400kv': '#0f056e', '500kv': '#6004f5',
                'mv': '#f00606', 
                'telecom': '#3B82F6', 'roads': '#3c363c', 'Asphalt': '#121212',
                'Power_Plants': '#10B981', 'Sub_Station': '#EF4444',
                'Transformer': '#FFA500', 'Railway': '#5e5b59', 'Railway_Substation': '#800080',
                'airports': '#F59E0B',
                'ethiopia_regions': '#080202',
                'ethiopia_zones': '#393737',
                'ethiopia_woredas': '#702929',
                'Safaricom': '#0072ce'
            };
            return colors[layerId] || '#6b7280';
        }
        
        function getLayerWeight(layerId) {
            const weights = {
                '132kv': 4, '230kv': 4, '400kv': 4, '500kv': 4,
                'mv': 2,
                'telecom': 3, 'roads': 4, 'Asphalt': 3,
                'Railway': 4,
                'transformer': 2,
                'ethiopia_regions': 2,
                'ethiopia_zones': 1.5,
                'ethiopia_woredas': 1
            };
            return weights[layerId] || 4;
        }

        // Toggle visibility of layers based on checkbox state and zoom level
        function updateLayersVisibilityByZoom() {
            const currentZoom = map.getZoom();
            updateZoomLevelInfo();
            
            Object.keys(mapLayers).forEach(layerId => {
                const layer = mapLayers[layerId];
                if (!layer) return;

                const isCheckboxChecked = document.getElementById(layerId)?.checked || false;
                const zoomThreshold = ZOOM_THRESHOLDS[layerId] || 0;
                const shouldBeVisible = isCheckboxChecked && currentZoom >= zoomThreshold;

                if (shouldBeVisible) {
                    if (!map.hasLayer(layer)) {
                        map.addLayer(layer);
                    }
                } else {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                }
            });
        }
        
        function formatProperties(properties) {
            if (!properties) return '<div class="property-row"><div class="property-value">No properties available.</div></div>';
            let html = '<div class="feature-properties">' 
            for (const [key, value] of Object.entries(properties)) {
                html += `<div class="property-row"><div class="property-name">${key}:</div><div class="property-value">${value !== null ? value : 'N/A'}</div></div>`;
            }
            html += '</div>';
            return html;
        }
        
        // Event listeners for layer checkboxes
        document.querySelectorAll('.layer-item input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                updateLayersVisibilityByZoom();
            });
        });
        
        // Event listeners for category headers to collapse/expand
        document.querySelectorAll('.category-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const icon = header.querySelector('.collapse-icon');
                if (content.classList.contains('expanded')) {
                    content.classList.remove('expanded');
                    icon.textContent = '▼';
                } else {
                    content.classList.add('expanded');
                    icon.textContent = '▲';
                }
            });
        });

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        const searchClearButton = document.getElementById('search-clear-button');
        const searchContainer = document.getElementById('search-container');
        const searchToggle = document.getElementById('search-toggle');
        let searchTimeout;
        
        // Toggle search container
        searchToggle.addEventListener('click', function() {
            searchContainer.classList.toggle('collapsed');
            if (searchContainer.classList.contains('collapsed')) {
                searchToggle.innerHTML = '<i class="fas fa-search"></i>';
            } else {
                searchToggle.innerHTML = '<i class="fas fa-times"></i>';
                searchInput.focus();
            }
        });
        
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            searchClearButton.style.display = query.length > 0 ? 'block' : 'none';

            if (query.length < 2) {
                searchResults.style.display = 'none';
                updateSearchInfo('Enter at least 2 characters to search');
                if (currentSearchMarker) {
                    map.removeLayer(currentSearchMarker);
                    currentSearchMarker = null;
                }
                return;
            }
            
            searchTimeout = setTimeout(() => {
                performServerSideSearch(query);
            }, 300);
        });

        async function performServerSideSearch(query) {
            showLoading('Searching database...');
            updateSearchInfo(`Searching for "${query}"...`);
            
            try {
                const searchResponse = await authFetch(`${API_URL}/search?q=${encodeURIComponent(query)}`);
                const data = await searchResponse.json();
                
                if (data.error) {
                    console.error("Search Error:", data.error);
                    showMessageBox("Search failed. Check the console for details.");
                    updateSearchInfo('Search failed.');
                    displaySearchResults([]);
                } else {
                    updateSearchInfo(`Found ${data.results.length} results`);
                    displaySearchResults(data.results);
                }
            } catch (error) {
                console.error("Network or search error:", error);
                showMessageBox("Search failed. Please ensure the Flask server is running.");
                updateSearchInfo('Search failed. Server connection error.');
                displaySearchResults([]);
            } finally {
                hideLoading();
            }
        }

        function displaySearchResults(results) {
            searchResults.innerHTML = '';
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
            } else {
                const limitedResults = results.slice(0, 20);
                
                limitedResults.forEach(result => {
                    let displayText = 'Unnamed feature';
                    const possibleNames = ['name', 'Name', 'NAME', 'id', 'OBJECTID'];
                    
                    for (const prop of possibleNames) {
                        if (result.properties && result.properties[prop]) {
                            displayText = result.properties[prop];
                            break;
                        }
                    }
                    
                    const div = document.createElement('div');
                    div.className = 'search-result-item';
                    div.innerHTML = `<strong>${displayText}</strong><br><small class="text-gray-500">Type: ${result.type}</small>`;
                    div.addEventListener('click', () => {
                        zoomToResult(result);
                        searchResults.style.display = 'none';
                    });
                    searchResults.appendChild(div);
                });
                
                if (results.length > 20) {
                    const moreResults = document.createElement('div');
                    moreResults.className = 'search-result-item text-gray-500';
                    moreResults.textContent = `... and ${results.length - 20} more results`;
                    searchResults.appendChild(moreResults);
                }
            }
            searchResults.style.display = 'block';
        }

        searchClearButton.addEventListener('click', function() {
            searchInput.value = '';
            searchResults.innerHTML = '';
            searchResults.style.display = 'none';
            searchClearButton.style.display = 'none';
            updateSearchInfo('Search cleared');
            if (currentSearchMarker) {
                map.removeLayer(currentSearchMarker);
                currentSearchMarker = null;
            }
        });
        
        function zoomToResult(result) {
            if (currentSearchMarker) {
                map.removeLayer(currentSearchMarker);
            }
            
            const featureLayer = L.geoJSON(result.geojson, {
                pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: "#ff0000",
                    color: "#ffffff",
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }),
                style: () => ({
                    color: "#ff0000",
                    weight: 4,
                    opacity: 0.8,
                    fillOpacity: 0.1
                })
            });
            
            currentSearchMarker = featureLayer;
            map.addLayer(featureLayer);
            
            // Zoom to the bounds of the result
            const bounds = featureLayer.getBounds();
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
            
            // Open popup with result information
            featureLayer.eachLayer(layer => {
                if (layer.getPopup) {
                    layer.openPopup();
                }
            });
        }

        // Toggle base layer control box
        document.getElementById('base-layer-toggle').addEventListener('click', function() {
            const content = document.getElementById('base-layer-content');
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
        });

        // Toggle layer control panel
        document.getElementById('layer-control-button').addEventListener('click', function() {
            const panel = document.getElementById('layer-control');
            panel.classList.toggle('show');
        });

        // Initialize the map when it loads
        map.whenReady(() => {
            loadLayersFromBackend();
            
            // Update layer visibility when zoom changes
            map.on('zoomend', updateLayersVisibilityByZoom);
            
            // Update zoom level info
            map.on('zoom', updateZoomLevelInfo);
            updateZoomLevelInfo();
            
            // Initialize category expansion
            document.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('expanded');
            });
            
            // Move zoom controls to bottom right
            const zoomControl = document.querySelector('.leaflet-control-zoom');
            if (zoomControl) {
                zoomControl.style.marginBottom = '80px';
                zoomControl.style.marginRight = '0';
            }
        });
    </script>
   <!-- Buffer Control Panel -->
<div id="buffer-control" class="buffer-control-panel">
    <h3 class="text-lg font-bold mb-2"><i class="fas fa-draw-polygon"></i> Buffer Analysis</h3>
    
    <div class="buffer-section">
        <div class="buffer-section-title">Buffer Settings</div>
        <div class="buffer-input-group">
            <label>Buffer Distance:</label>
            <input type="number" id="buffer-distance" class="buffer-input" min="10" max="10000" step="10" value="500">
            <select id="buffer-unit" class="buffer-unit">
                <option value="meters">Meters</option>
                <option value="kilometers">Kilometers</option>
                <option value="feet">Feet</option>
                <option value="miles">Miles</option>
            </select>
        </div>
    </div>
    
    <div class="buffer-section">
        <div class="buffer-section-title">Options</div>
        <div class="buffer-option">
            <input type="checkbox" id="show-intersections" class="mr-2" checked>
            <label for="show-intersections">Show Intersections</label>
        </div>
    </div>
    
    <button id="apply-buffer" class="buffer-button">
        <i class="fas fa-draw-circle"></i> Create Buffer
    </button>
    <button id="clear-buffers" class="buffer-clear-button">
        <i class="fas fa-trash"></i> Clear All
    </button>
    
    <!-- Buffer Results Panel -->
<div id="buffer-results" class="buffer-results">
    <div class="buffer-section-title" style="display: flex; justify-content: space-between; align-items: center;">
        <span>📋 Created Buffers</span>
        <button class="close-btn" onclick="bufferManager.hideResults()" style="background: none; border: none; font-size: 16px; cursor: pointer;">×</button>
    </div>
    <div id="buffer-result-content" class="buffer-result-content">
        <!-- Buffer list will be populated here -->
    </div>
    <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
        <small style="color: #666;">💡 Click on buffers to highlight them</small>
    </div>
</div>
    
    <div class="buffer-section">
        <div class="buffer-help">
            <small><strong>How to use:</strong> Click "Create Buffer", then click on any point, line, or polygon feature on the map.</small>
        </div>
    </div>
</div>

<!-- Buffer control button -->
<div class="buffer-icon-button" id="buffer-control-button">
    <i class="fas fa-draw-polygon"></i>
</div>
<!-- Add this JavaScript to your existing script section -->
 <script>
// Buffer functionality - Simplified and reliable version
class BufferManager {
    constructor(map) {
        this.map = map;
        this.bufferLayers = [];
        this.intersectionLayers = [];
        this.isSelecting = false;
        this.currentClickListener = null;
        this.selectionLayer = null;
        
        this.initBufferTools();
    }

    initBufferTools() {
        // Initialize buffer controls
        this.setupBufferControls();
    }

    setupBufferControls() {
        // Buffer control event listeners
        document.getElementById('apply-buffer').addEventListener('click', () => {
            this.startSelectionMode();
        });

        document.getElementById('clear-buffers').addEventListener('click', () => {
            this.clearAllBuffers();
        });

        // Buffer control panel toggle
        document.getElementById('buffer-control-button').addEventListener('click', () => {
            const panel = document.getElementById('buffer-control');
            panel.classList.toggle('show');
        });
    }

    startSelectionMode() {
        if (this.isSelecting) {
            this.stopSelectionMode();
            return;
        }

        this.isSelecting = true;
        
        const bufferDistance = parseFloat(document.getElementById('buffer-distance').value);
        const bufferUnit = document.getElementById('buffer-unit').value;
        
        if (isNaN(bufferDistance) || bufferDistance <= 0) {
            this.showMessage('Please enter a valid buffer distance');
            this.isSelecting = false;
            return;
        }

        this.showMessage('🎯 Click on ANY feature (power lines, airports, roads, etc.) to create a buffer');
        this.map.getContainer().style.cursor = 'crosshair';

        // Create a temporary transparent layer that captures all clicks
        this.createSelectionLayer();
        
        // Add click listener to the selection layer
        this.currentClickListener = (e) => {
            this.handleSelectionClick(e, bufferDistance, bufferUnit);
        };
        
        this.selectionLayer.on('click', this.currentClickListener);
    }

    createSelectionLayer() {
        // Create a transparent rectangle that covers the entire map
        this.selectionLayer = L.rectangle(this.map.getBounds(), {
            color: 'transparent',
            weight: 0,
            fillColor: 'transparent',
            fillOpacity: 0,
            className: 'buffer-selection-layer',
            interactive: true
        }).addTo(this.map);
    }

    handleSelectionClick(e, distance, unit) {
        if (!this.isSelecting) return;

        const clickedPoint = e.latlng;
        
        console.log('Selection layer clicked at:', clickedPoint);
        
        // Find the actual feature that was clicked using a different approach
        const clickedFeature = this.findClickedFeature(clickedPoint);
        
        if (clickedFeature) {
            console.log('Found feature for buffering:', clickedFeature);
            this.stopSelectionMode();
            this.createBufferFromFeature(clickedFeature.feature, distance, unit, clickedFeature.layerId);
        } else {
            this.showMessage('❌ No feature found. Click directly on power lines, roads, airports, etc.');
        }
    }

    findClickedFeature(clickedPoint) {
        // Get the current zoom level
        const zoom = this.map.getZoom();
        
        // Try multiple approaches to find the clicked feature
        
        // Approach 1: Check if any feature layer contains the point
        for (const layerId in mapLayers) {
            const layer = mapLayers[layerId];
            const checkbox = document.getElementById(layerId);
            
            if (!layer || !checkbox || !checkbox.checked || !map.hasLayer(layer)) {
                continue;
            }
            
            let foundFeature = null;
            
            layer.eachLayer((featureLayer) => {
                if (foundFeature) return;
                
                // Check if this feature layer was clicked
                if (this.isFeatureClicked(featureLayer, clickedPoint, zoom)) {
                    foundFeature = {
                        feature: featureLayer.feature,
                        layerId: layerId,
                        featureLayer: featureLayer
                    };
                }
            });
            
            if (foundFeature) {
                return foundFeature;
            }
        }
        
        return null;
    }

    isFeatureClicked(featureLayer, clickedPoint, zoom) {
        if (!featureLayer.feature || !featureLayer.feature.geometry) return false;
        
        const geometryType = featureLayer.feature.geometry.type;
        const tolerance = this.getToleranceForZoom(zoom);
        
        switch (geometryType) {
            case 'Point':
                return this.isPointClicked(featureLayer, clickedPoint, tolerance);
            case 'LineString':
            case 'MultiLineString':
                return this.isLineClicked(featureLayer, clickedPoint, tolerance);
            case 'Polygon':
            case 'MultiPolygon':
                return this.isPolygonClicked(featureLayer, clickedPoint);
            default:
                return false;
        }
    }

    isPointClicked(featureLayer, clickedPoint, tolerance) {
        const point = featureLayer.getLatLng ? featureLayer.getLatLng() : null;
        if (!point) return false;
        
        const distance = clickedPoint.distanceTo(point);
        return distance <= tolerance;
    }

    isLineClicked(featureLayer, clickedPoint, tolerance) {
        try {
            const latlngs = featureLayer.getLatLngs ? featureLayer.getLatLngs() : null;
            if (!latlngs) return false;
            
            // Flatten the latlngs array in case it's nested
            const flatLatLngs = this.flattenLatLngs(latlngs);
            
            for (let i = 0; i < flatLatLngs.length - 1; i++) {
                const distance = this.distanceToSegment(clickedPoint, flatLatLngs[i], flatLatLngs[i + 1]);
                if (distance <= tolerance) {
                    return true;
                }
            }
        } catch (error) {
            console.error('Error checking line click:', error);
        }
        return false;
    }

    isPolygonClicked(featureLayer, clickedPoint) {
        try {
            const latlngs = featureLayer.getLatLngs ? featureLayer.getLatLngs() : null;
            if (!latlngs) return false;
            
            // For polygons, check if point is inside
            const polygon = L.polygon(latlngs);
            const bounds = polygon.getBounds();
            return bounds.contains(clickedPoint);
        } catch (error) {
            console.error('Error checking polygon click:', error);
        }
        return false;
    }

    flattenLatLngs(latlngs) {
        const result = [];
        
        const flatten = (arr) => {
            if (Array.isArray(arr) && arr.length > 0 && L.LatLng.prototype.isPrototypeOf(arr[0])) {
                result.push(...arr);
            } else if (Array.isArray(arr)) {
                arr.forEach(item => flatten(item));
            }
        };
        
        flatten(latlngs);
        return result;
    }

    getToleranceForZoom(zoom) {
        // Return tolerance in meters based on zoom level
        const tolerances = {
            6: 5000,   // Very low zoom - large tolerance
            8: 2000,   // Low zoom
            10: 1000,  // Medium zoom
            12: 500,   // Medium-high zoom
            14: 200,   // High zoom
            16: 100,   // Very high zoom
            18: 50     // Maximum zoom
        };
        
        return tolerances[zoom] || 500; // Default tolerance
    }

    async createBufferFromFeature(feature, distance, unit, layerId) {
        const geometryType = feature.geometry.type;
        
        console.log('Creating buffer for:', geometryType, 'from layer:', layerId);
        
        // Show loading message
        this.showMessage('🔄 Creating buffer...');
        
        // Prepare the feature data for the backend
        const featureData = {
            type: 'Feature',
            geometry: feature.geometry,
            properties: feature.properties || {}
        };

        const showIntersections = document.getElementById('show-intersections').checked;
        const layerNames = showIntersections ? this.getIntersectionLayers(layerId) : [];

        try {
            // Call Flask backend to create buffer
            const response = await fetch('/api/buffer/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    features: [featureData],
                    distance: distance,
                    unit: unit,
                    layerNames: layerNames
                })
            });

            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                // Display the buffer from backend
                if (data.buffers && data.buffers.length > 0) {
                    data.buffers.forEach(buffer => {
                        this.displayBufferOnMap(buffer, geometryType, layerId, distance, unit);
                    });
                }
                
                // Display intersections if any
                if (data.intersections && data.intersections.length > 0) {
                    this.displayIntersections(data.intersections);
                }
                
                this.showMessage(`✅ ${geometryType} buffer created! Found ${data.intersections.length} intersections.`);
            } else {
                throw new Error(data.error || 'Failed to create buffer');
            }
            
        } catch (error) {
            console.error('Error calling buffer API:', error);
            this.showMessage('⚠️ Using client-side buffer creation');
            this.createClientSideBuffer(feature, distance, unit, geometryType, layerId, showIntersections);
        }
    }

    displayBufferOnMap(bufferData, geometryType, layerId, distance, unit) {
        try {
            // Create Leaflet layer from GeoJSON buffer
            const bufferLayer = L.geoJSON(bufferData, {
                style: {
                    color: this.getBufferColor(geometryType),
                    weight: 3,
                    fillColor: this.getBufferColor(geometryType),
                    fillOpacity: 0.3
                }
            }).addTo(this.map);
            
            // Add popup with buffer info
            bufferLayer.bindPopup(`
                <div class="popup-header">${geometryType} Buffer</div>
                <div class="property-row">
                    <div class="property-name">Source:</div>
                    <div class="property-value">${layerId}</div>
                </div>
                <div class="property-row">
                    <div class="property-name">Distance:</div>
                    <div class="property-value">${distance} ${unit}</div>
                </div>
            `);
            
        
        this.bufferLayers.push(bufferLayer);
        
        // UPDATE THE RESULTS LIST
        this.updateBufferResults();
        
        } catch (error) {
        console.error('Error displaying buffer:', error);
         }

    }

    createClientSideBuffer(feature, distance, unit, geometryType, layerId, showIntersections) {
        const distanceInMeters = this.convertToMeters(distance, unit);
        
        let bufferLayer;
        switch(geometryType) {
            case 'Point':
                bufferLayer = this.createSimplePointBuffer(feature, distanceInMeters);
                break;
            case 'LineString':
            case 'MultiLineString':
                bufferLayer = this.createSimpleLineBuffer(feature, distanceInMeters);
                break;
            case 'Polygon':
            case 'MultiPolygon':
                bufferLayer = this.createSimplePolygonBuffer(feature, distanceInMeters);
                break;
            default:
                this.showMessage('❌ Unsupported geometry type');
                return;
        }
    
    if (bufferLayer) {
        this.bufferLayers.push(bufferLayer);
        // UPDATE THE RESULTS LIST
        this.updateBufferResults();
        this.showMessage(`✅ ${geometryType} buffer created (client-side)!`);
    }

    }

    createSimplePointBuffer(feature, distance) {
        const coords = feature.geometry.coordinates;
        const latlng = L.latLng(coords[1], coords[0]);
        
        return L.circle(latlng, {
            radius: distance,
            color: '#3B82F6',
            weight: 2,
            fillColor: '#3B82F6',
            fillOpacity: 0.2
        }).addTo(this.map);
    }

    createSimpleLineBuffer(feature, distance) {
        try {
            const coords = feature.geometry.type === 'LineString' ? 
                feature.geometry.coordinates : 
                feature.geometry.coordinates[0];
                
            const latlngs = coords.map(coord => L.latLng(coord[1], coord[0]));
            
            // Create buffer circles along the line
            const bufferGroup = L.layerGroup();
            latlngs.forEach(latlng => {
                const circle = L.circle(latlng, {
                    radius: distance,
                    color: '#10B981',
                    weight: 1,
                    fillColor: '#10B981',
                    fillOpacity: 0.15
                });
                bufferGroup.addLayer(circle);
            });
            
            bufferGroup.addTo(this.map);
            return bufferGroup;
            
        } catch (error) {
            console.error('Error creating line buffer:', error);
            return null;
        }
    }

    createSimplePolygonBuffer(feature, distance) {
        try {
            const coords = feature.geometry.type === 'Polygon' ? 
                feature.geometry.coordinates[0] : 
                feature.geometry.coordinates[0][0];
                
            const latlngs = coords.map(coord => L.latLng(coord[1], coord[0]));
            
            // Create buffer circles at polygon vertices
            const bufferGroup = L.layerGroup();
            latlngs.forEach(latlng => {
                const circle = L.circle(latlng, {
                    radius: distance,
                    color: '#EF4444',
                    weight: 1,
                    fillColor: '#EF4444',
                    fillOpacity: 0.15
                });
                bufferGroup.addLayer(circle);
            });
            
            bufferGroup.addTo(this.map);
            return bufferGroup;
            
        } catch (error) {
            console.error('Error creating polygon buffer:', error);
            return null;
        }
    }

    stopSelectionMode() {
        this.isSelecting = false;
        this.map.getContainer().style.cursor = '';
        
        // Remove click listener
        if (this.currentClickListener && this.selectionLayer) {
            this.selectionLayer.off('click', this.currentClickListener);
            this.currentClickListener = null;
        }
        
        // Remove selection layer
        if (this.selectionLayer) {
            this.map.removeLayer(this.selectionLayer);
            this.selectionLayer = null;
        }
    }
    // Add this method to update the buffer results list
updateBufferResults() {
    const resultsContent = document.getElementById('buffer-result-content');
    const resultsPanel = document.getElementById('buffer-results');
    
    console.log('Updating buffer results. Total buffers:', this.bufferLayers.length);
    
    if (this.bufferLayers.length === 0) {
        resultsPanel.style.display = 'none';
        return;
    }
    
    // Show the results panel
    resultsPanel.style.display = 'block';
    resultsContent.innerHTML = '';
    
    // Add each buffer to the results list
    this.bufferLayers.forEach((bufferLayer, index) => {
        const resultItem = document.createElement('div');
        resultItem.className = 'buffer-result-item';
        resultItem.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start;">
                <div style="flex: 1;">
                    <strong>Buffer ${index + 1}</strong>
                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                        ${this.getBufferInfo(bufferLayer)}
                    </div>
                </div>
            </div>
            <div class="buffer-actions">
                <button class="buffer-action-btn zoom" onclick="bufferManager.zoomToBuffer(${index})">
                    <i class="fas fa-search"></i> Zoom
                </button>
                <button class="buffer-action-btn remove" onclick="bufferManager.removeBuffer(${index})">
                    <i class="fas fa-times"></i> Remove
                </button>
            </div>
        `;
        
        // Add click event to highlight the buffer
        resultItem.addEventListener('click', (e) => {
            if (!e.target.closest('.buffer-action-btn')) {
                this.highlightBuffer(bufferLayer, index);
            }
        });
        
        resultsContent.appendChild(resultItem);
    });
    
    console.log('Buffer results updated successfully');
}

// Add this method to get buffer information
getBufferInfo(bufferLayer) {
    try {
        // Try to get information from the buffer layer
        if (bufferLayer.feature && bufferLayer.feature.properties) {
            const props = bufferLayer.feature.properties;
            if (props.original_feature_type) {
                return `${props.original_feature_type} Buffer`;
            }
            if (props.buffer_type) {
                return `${props.buffer_type.replace('_', ' ')} Buffer`;
            }
        }
        
        // Check if it's a circle (point buffer)
        if (bufferLayer.getRadius) {
            return `Point Buffer (${Math.round(bufferLayer.getRadius())}m)`;
        }
        
        // Check if it's a layer group (line/polygon buffer)
        if (bufferLayer.eachLayer) {
            let layerCount = 0;
            bufferLayer.eachLayer(() => layerCount++);
            return `Complex Buffer (${layerCount} elements)`;
        }
        
        return 'Custom Buffer';
    } catch (error) {
        return 'Buffer';
    }
}

// Add this method to zoom to a specific buffer
zoomToBuffer(bufferIndex) {
    if (bufferIndex >= 0 && bufferIndex < this.bufferLayers.length) {
        const bufferLayer = this.bufferLayers[bufferIndex];
        
        if (bufferLayer.getBounds) {
            // For layers that have bounds (GeoJSON, Polygon, etc.)
            const bounds = bufferLayer.getBounds();
            this.map.fitBounds(bounds, { padding: [20, 20] });
        } else if (bufferLayer.getLatLng && bufferLayer.getRadius) {
            // For circle buffers (points)
            const center = bufferLayer.getLatLng();
            const radius = bufferLayer.getRadius();
            const bounds = L.latLngBounds(
                [center.lat - radius/111320, center.lng - radius/(111320 * Math.cos(center.lat * Math.PI/180))],
                [center.lat + radius/111320, center.lng + radius/(111320 * Math.cos(center.lat * Math.PI/180))]
            );
            this.map.fitBounds(bounds, { padding: [20, 20] });
        }
        
        this.highlightBuffer(bufferLayer, bufferIndex);
        this.showMessage(`🔍 Zoomed to Buffer ${bufferIndex + 1}`);
    }
}

// Add this method to highlight a buffer
highlightBuffer(bufferLayer, bufferIndex) {
    // Remove previous highlights
    this.removeBufferHighlights();
    
    // Add highlight to the list item
    const resultItems = document.querySelectorAll('.buffer-result-item');
    if (resultItems[bufferIndex]) {
        resultItems[bufferIndex].classList.add('active');
    }
    
    // Add visual highlight to the map
    if (bufferLayer.setStyle) {
        // Store original style
        bufferLayer._originalStyle = {
            weight: bufferLayer.options.weight || 3,
            fillOpacity: bufferLayer.options.fillOpacity || 0.3,
            color: bufferLayer.options.color
        };
        
        // Apply highlight style
        bufferLayer.setStyle({
            weight: 5,
            fillOpacity: 0.5
        });
        
        // Bring to front
        if (bufferLayer.bringToFront) {
            bufferLayer.bringToFront();
        }
    }
    
    // Auto-remove highlight after 3 seconds
    setTimeout(() => {
        this.removeBufferHighlights();
    }, 3000);
}

// Add this method to remove buffer highlights
removeBufferHighlights() {
    // Remove highlights from list items
    document.querySelectorAll('.buffer-result-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Revert buffer styles
    this.bufferLayers.forEach(bufferLayer => {
        if (bufferLayer._originalStyle && bufferLayer.setStyle) {
            bufferLayer.setStyle(bufferLayer._originalStyle);
        }
    });
}

// Add this method to remove a specific buffer
removeBuffer(bufferIndex) {
    if (bufferIndex >= 0 && bufferIndex < this.bufferLayers.length) {
        const bufferLayer = this.bufferLayers[bufferIndex];
        
        // Remove from map
        this.map.removeLayer(bufferLayer);
        
        // Remove from array
        this.bufferLayers.splice(bufferIndex, 1);
        
        // Update the results list
        this.updateBufferResults();
        
        this.showMessage(`🗑️ Buffer ${bufferIndex + 1} removed`);
    }
}

// Add this method to hide the results panel
hideResults() {
    const resultsPanel = document.getElementById('buffer-results');
    resultsPanel.style.display = 'none';
}

    clearAllBuffers() {
        this.stopSelectionMode();
    
    
        // Clear all buffers
        this.bufferLayers.forEach(layer => {
            this.map.removeLayer(layer);
        });
        this.bufferLayers = [];
        this.updateBufferResults();
        // Clear intersections
        this.intersectionLayers.forEach(layer => {
            this.map.removeLayer(layer);
        });
        this.intersectionLayers = [];
        
        this.showMessage('🗑️ All buffers cleared');
    }

    getIntersectionLayers(excludeLayer) {
        return Object.keys(mapLayers).filter(layerId => 
            layerId !== excludeLayer && document.getElementById(layerId)?.checked
        );
    }

    convertToMeters(distance, unit) {
        switch(unit) {
            case 'meters': return distance;
            case 'kilometers': return distance * 1000;
            case 'feet': return distance * 0.3048;
            case 'miles': return distance * 1609.34;
            default: return distance;
        }
    }

    getBufferColor(geometryType) {
        const colors = {
            'Point': '#3B82F6',
            'LineString': '#10B981',
            'MultiLineString': '#10B981',
            'Polygon': '#EF4444',
            'MultiPolygon': '#EF4444'
        };
        return colors[geometryType] || '#6b7280';
    }

    distanceToSegment(point, linePoint1, linePoint2) {
        // Simplified distance calculation
        const dx = linePoint2.lng - linePoint1.lng;
        const dy = linePoint2.lat - linePoint1.lat;
        
        const lengthSquared = dx * dx + dy * dy;
        if (lengthSquared === 0) return point.distanceTo(linePoint1);
        
        const t = Math.max(0, Math.min(1, ((point.lng - linePoint1.lng) * dx + (point.lat - linePoint1.lat) * dy) / lengthSquared));
        
        const projection = {
            lng: linePoint1.lng + t * dx,
            lat: linePoint1.lat + t * dy
        };
        
        return point.distanceTo(projection);
    }

    showMessage(message) {
        const msgBox = document.getElementById('message-box');
        if (msgBox) {
            msgBox.textContent = message;
            msgBox.classList.add('show');
            setTimeout(() => {
                msgBox.classList.remove('show');
            }, 4000);
        }
    }

    displayIntersections(intersections) {
        // Optional: Display intersections if needed
        intersections.forEach(intersection => {
            // Implementation for displaying intersections
        });
    }
}

// Initialize buffer manager
let bufferManager;
map.whenReady(() => {
    bufferManager = new BufferManager(map);
    setTimeout(() => {
        bufferManager.showMessage('🛠️ Buffer tools ready. Click "Create Buffer" then click on features.');
    }, 2000);
});
</script>
</body>
</html>